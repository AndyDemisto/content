commonfields:
  id: pyEWS
  version: -1
name: pyEWS
display: pyEWS
category: Messaging
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAAyCAYAAAATIfj2AAAACXBIWXMAAAsTAAALEwEAmpwYAAA7oGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMTEgNzkuMTU4MzI1LCAyMDE1LzA5LzEwLTAxOjEwOjIwICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNSAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMi0xNlQyMDozOTo1NCswMjowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE2LTAzLTA4VDE0OjI1OjQxKzAyOjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNi0wMy0wOFQxNDoyNTo0MSswMjowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDpmZDgyZDE4NC03OWNiLTQ5MDAtOGViNC00YzYyNWIxZjM3MGU8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPnhtcC5kaWQ6ZTBhOGJjMDAtZTZlZS00NGRiLTg4NTYtYzliZWViMjcyYTgxPC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6ZTBhOGJjMDAtZTZlZS00NGRiLTg4NTYtYzliZWViMjcyYTgxPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmUwYThiYzAwLWU2ZWUtNDRkYi04ODU2LWM5YmVlYjI3MmE4MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMi0xNlQyMDozOTo1NCswMjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIwNWQ5NmJmLTY5MmUtNDRiMS1hNTMwLWFjN2VjOGRhYjY3MDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMi0xOFQxMjo1MzoyNiswMjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmZkODJkMTg0LTc5Y2ItNDkwMC04ZWI0LTRjNjI1YjFmMzcwZTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMy0wOFQxNDoyNTo0MSswMjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjUyPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjUwPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAg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
description: Exchange Web Services and Office 365 (mail)
detaileddescription: |-
  For Office 365, use https://outlook.office365.com/EWS/Exchange.asmx (default) as the Server  URL.
  Default version is used when accessing the EWS API to determine the API version.
  By default Demisto uses the Exchange2010 version.
  It is recommended not to change this value unless you run into issues.
  The default value can be bypassed in individual exchange commands by adding "version=Exhcange{yyyy}" where yyyy is the exchange version.

  To fetch emails from a specific folder, folder ID needs to be specified, this ID can be fetched using the ews-find-folders command
configuration:
- display: Server URL or Server IP address
  name: ewsServer
  defaultvalue: https://outlook.office365.com/EWS/Exchange.asmx/
  type: 0
  required: true
- display: ""
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Domain
  name: domain
  defaultvalue: ""
  type: 0
  required: true
- display: Default Target Mailbox. If empty - username mailbox will be used
  name: defaultTargetMailbox
  defaultvalue: ""
  type: 0
  required: false
- display: Server Version (2007,2010,2010_SP2,2013,2016)
  name: defaultServerVersion
  defaultvalue: "2013"
  type: 0
  required: true
- display: Authentication Type (NTLM or Basic or Digest)
  name: authType
  defaultvalue: NTLM
  type: 0
  required: true
- display: Has impersonation rights.
  name: impersonation
  defaultvalue: "false"
  type: 8
  required: false
- display: Do not validate server certificate (insecure)
  name: insecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Folder Name to fetch incidents from
  name: folder
  defaultvalue: Inbox
  type: 0
  required: false
script:
  script: |-
    from exchangelib.errors import ErrorItemNotFound, ErrorAccessDenied
    from exchangelib.items import Item, Message

    import json
    from datetime import timedelta

    from exchangelib.services import EWSService
    from exchangelib.util import create_element, add_xml_child
    from exchangelib.transport import MNS, TNS

    from exchangelib import IMPERSONATION, DELEGATE, Account, ServiceAccount, \
        EWSDateTime, EWSTimeZone, Configuration, NTLM, DIGEST, BASIC, FileAttachment, \
        Version, Folder, HTMLBody, Body
    from exchangelib.version import EXCHANGE_2007, EXCHANGE_2010, EXCHANGE_2010_SP2, EXCHANGE_2013, EXCHANGE_2016
    from exchangelib.protocol import BaseProtocol, NoVerifyHTTPAdapter

    # disable warnings print
    import warnings

    warnings.filterwarnings("ignore")

    # consts

    VERSIONS = {
        '2007': EXCHANGE_2007,
        '2010': EXCHANGE_2010,
        '2010_SP2': EXCHANGE_2010_SP2,
        '2013': EXCHANGE_2013,
        '2016': EXCHANGE_2016
    }

    # load arguments

    USE_PROXY = demisto.params()['proxy']
    NON_SECURE = demisto.params()['insecure']
    AUTH_METHOD_STR = demisto.params()['authType'].lower()
    VERSION_STR = demisto.params()['defaultServerVersion']
    EWS_SERVER = demisto.params()['ewsServer']
    USERNAME = demisto.params()['credentials']['identifier']
    DOMAIN = demisto.params()['domain']
    ACCOUNT_EMAIL = demisto.params().get('defaultTargetMailbox')
    if not ACCOUNT_EMAIL:
        ACCOUNT_EMAIL = USERNAME + "@" + DOMAIN
    if not USERNAME.lower().startswith(DOMAIN.lower()):
        USERNAME = DOMAIN + "\\" + USERNAME
    PASSWORD = demisto.params()['credentials']['password']
    FOLDER_NAME = demisto.params()['folder']
    ACCESS_TYPE = IMPERSONATION if demisto.params()['impersonation'] else DELEGATE
    FETCH_ALL_HISTORY = demisto.params().get('fetchAllHistory', False)


    def get_entry_for_object(title, context_key, obj, headers=None):
        return {
            'Type': entryTypes['note'],
            'Contents': obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, obj, headers),
            'EntryContext': {
                context_key: obj
            }
        }


    def get_auth_method(auth_method):
        auth_method = auth_method.lower()
        if auth_method == 'ntlm':
            return NTLM
        elif auth_method == 'basic':
            return BASIC
        elif auth_method == 'digest':
            return DIGEST
        raise Exception("Auth method not supported: %s" % auth_method)


    def get_items_from_mailbox(account, item_ids):
        if type(item_ids) is not list:
            item_ids = [item_ids]
        items = map(lambda x: Item(item_id=x), item_ids)
        result = list(account.fetch(ids=items))
        result = [x for x in result if not isinstance(x, ErrorItemNotFound)]
        for item in result:
            item.folder = Folder(account=account)
        return result


    def get_item_from_mailbox(account, item_id):
        return get_items_from_mailbox(account, [item_id])[0]


    def get_version(version_str):
        if version_str not in VERSIONS:
            raise Exception("Version is incorrect: %s" % version_str)
        return Version(VERSIONS[version_str])


    def get_folder_by_path(folder, path):
        path = path.split('\\')
        folder_result = folder
        for sub_folder_name in path:
            folder_result = folder_result.get_folder_by_name(sub_folder_name)

        return folder_result


    def prepare():
        if NON_SECURE:
            BaseProtocol.HTTP_ADAPTER_CLS = NoVerifyHTTPAdapter

        if not USE_PROXY:
            def remove_from_dict(d, key):
                if key in d:
                    del d[key]

            import os

            remove_from_dict(os.environ, 'HTTP_PROXY')
            remove_from_dict(os.environ, 'http_proxy')
            remove_from_dict(os.environ, 'HTTPS_PROXY')
            remove_from_dict(os.environ, 'https_proxy')

        version = get_version(VERSION_STR)
        credentials = ServiceAccount(username=USERNAME, password=PASSWORD)
        config_args = {
            'credentials': credentials,
            'auth_type': get_auth_method(AUTH_METHOD_STR),
            'version': version
        }
        if 'http' in EWS_SERVER.lower():
            config_args['service_endpoint'] = EWS_SERVER
        else:
            config_args['server'] = EWS_SERVER
        config = Configuration(**config_args)
        return config


    class GetSearchableMailboxes(EWSService):
        SERVICE_NAME = 'GetSearchableMailboxes'
        element_container_name = '{%s}SearchableMailboxes' % MNS

        @staticmethod
        def parse_element(element):
            return {
                'mailbox': element.find("{%s}PrimarySmtpAddress" % TNS).text,
                'mailboxId': element.find("{%s}ReferenceId" % TNS).text,
                'displayName': element.find("{%s}DisplayName" % TNS).text,
                'isExternal': element.find("{%s}IsExternalMailbox" % TNS).text,
                'externalEmailAddress': element.find("{%s}ExternalEmailAddress" % TNS).text
            }

        def call(self):
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError('%s is only supported for Exchange 2013 servers and later' % self.SERVICE_NAME)
            elements = self._get_elements(payload=self.get_payload())
            return map(lambda x: self.parse_element(x), elements)

        def get_payload(self):
            element = create_element(
                'm:%s' % self.SERVICE_NAME,
            )
            return element


    class SearchMailboxes(EWSService):
        SERVICE_NAME = 'SearchMailboxes'
        element_container_name = '{%s}SearchMailboxesResult/{%s}Items' % (MNS, TNS)

        @staticmethod
        def parse_element(element):
            to_recipients = element.find('{%s}ToRecipients' % TNS)
            if to_recipients:
                to_recipients = map(lambda x: x.text, to_recipients)

            return {
                'messageId': element.find('{%s}Id' % TNS).attrib['Id'],
                'mailbox': element.find('{%s}Mailbox/{%s}PrimarySmtpAddress' % (TNS, TNS)).text,
                'subject': element.find("{%s}Subject" % TNS).text,
                'toRecipients': to_recipients,
                'sender': element.find("{%s}Sender" % TNS).text,
                'hasAttachment': element.find("{%s}HasAttachment" % TNS).text,
                'sentTime': element.find("{%s}SentTime" % TNS).text,
                'receivedTime': element.find("{%s}ReceivedTime" % TNS).text
            }

        def call(self, query, mailboxes):
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError('%s is only supported for Exchange 2013 servers and later' % self.SERVICE_NAME)
            elements = list(self._get_elements(payload=self.get_payload(query, mailboxes)))
            return map(lambda x: self.parse_element(x), elements)

        def get_payload(self, query, mailboxes):
            def get_mailbox_search_scope(mailbox_id):
                mailbox_search_scope = create_element("t:MailboxSearchScope")
                add_xml_child(mailbox_search_scope, "t:Mailbox", mailbox_id)
                add_xml_child(mailbox_search_scope, "t:SearchScope", "All")
                return mailbox_search_scope

            mailbox_query_element = create_element("t:MailboxQuery")
            add_xml_child(mailbox_query_element, "t:Query", query)
            mailboxes_scopes = []
            for mailbox in mailboxes:
                mailboxes_scopes.append(get_mailbox_search_scope(mailbox))
            add_xml_child(mailbox_query_element, "t:MailboxSearchScopes", mailboxes_scopes)

            element = create_element('m:%s' % self.SERVICE_NAME)
            add_xml_child(element, "m:SearchQueries", mailbox_query_element)
            add_xml_child(element, "m:ResultType", "PreviewOnly")

            return element


    def get_searchable_mailboxes(protocol):
        searchable_mailboxes = GetSearchableMailboxes(protocol=protocol).call()
        return get_entry_for_object("Searchable mailboxes", 'EWS.Mailboxes', searchable_mailboxes)


    def search_mailboxes(protocol, filter, mailbox_search_scope):
        search_results = SearchMailboxes(protocol=protocol).call(filter, mailbox_search_scope)
        entry = get_entry_for_object("Search mailboxes results", 'EWS.Searches.Search.Results', search_results)
        entry['EntryContext']['EWS.Searches.Search.Filter'] = filter
        return entry


    def get_account(account_email, access_type=ACCESS_TYPE):
        return Account(
            primary_smtp_address=account_email, autodiscover=False, config=config, access_type=access_type,
        )


    def get_last_run():
        last_run = demisto.getLastRun()
        if not last_run or last_run.get('folderName') != FOLDER_NAME:
            last_run = {
                'lastRunTime': None,
                'folderName': FOLDER_NAME,
                'ids': None
            }
        if 'lastRunTime' in last_run and last_run['lastRunTime'] is not None:
            last_run['lastRunTime'] = EWSDateTime.from_string(last_run['lastRunTime'])

        return last_run


    def fetch_last_emails(account, folder_name='Inbox', since_datetime=None, exclude_ids=None):
        qs = get_folder_by_path(account.root, folder_name)
        if since_datetime:
            qs = qs.filter(datetime_received__gte=since_datetime)
        else:
            if not FETCH_ALL_HISTORY:
                last_10_min = EWSDateTime.now(tz=EWSTimeZone.timezone('UTC')) - timedelta(minutes=10)
                qs = qs.filter(datetime_received__gte=last_10_min)
        if exclude_ids and len(exclude_ids) > 0:
            qs = qs.exclude(message_id__in=exclude_ids)
        return qs.all()


    def keys_to_camel_case(value):
        def str_to_camel_case(snake_str):
            components = snake_str.split('_')
            return components[0] + "".join(x.title() for x in components[1:])

        if value is None:
            return None
        if isinstance(value, list):
            return map(keys_to_camel_case, value)
        if isinstance(value, dict):
            return dict((keys_to_camel_case(k),
                         keys_to_camel_case(v) if isinstance(v, (list, dict)) else v)
                        for (k, v) in value.items())

        return str_to_camel_case(value)


    def parse_item_as_dict(item, camel_case=False, compact_fields=False):
        def parse_object_as_dict(object):
            raw_dict = {}
            for field in object.FIELDS:
                raw_dict[field.name] = getattr(object, field.name)
            return raw_dict

        def parse_attachment_as_raw_json(attachment):
            raw_dict = parse_object_as_dict(attachment)
            if raw_dict['attachment_id']:
                raw_dict['attachment_id'] = parse_object_as_dict(raw_dict['attachment_id'])
            if raw_dict['last_modified_time']:
                raw_dict['last_modified_time'] = raw_dict['last_modified_time'].ewsformat()
            return raw_dict

        def parse_folder_as_json(folder):
            raw_dict = parse_object_as_dict(folder)
            if 'parent_folder_id' in raw_dict:
                raw_dict['parent_folder_id'] = parse_folder_as_json(raw_dict['parent_folder_id'])
            if 'effective_rights' in raw_dict:
                raw_dict['effective_rights'] = parse_object_as_dict(raw_dict['effective_rights'])
            return raw_dict

        raw_dict = {}
        for field, value in item.__dict__.items():
            if type(value) in [str, unicode, int, float, bool, Body, HTMLBody, None]:
                try:
                    if isinstance(value, basestring):
                        value.encode('utf-8')
                    raw_dict[field] = value
                except:
                    pass

        if item.attachments:
            raw_dict['attachments'] = map(parse_attachment_as_raw_json, item.attachments)

        for time_field in ['datetime_sent', 'datetime_created', 'datetime_received', 'last_modified_time',
                           'reminder_due_by']:
            value = getattr(item, time_field)
            if value:
                raw_dict[time_field] = value.ewsformat()

        for dict_field in ['effective_rights', 'parent_folder_id', 'conversation_id', 'author',
                           'extern_id', 'received_by', 'received_representing', 'reply_to', 'sender', 'folder']:
            value = getattr(item, dict_field)
            if value:
                raw_dict[dict_field] = parse_object_as_dict(value)

        for list_dict_field in ['headers', 'cc_recipients', 'to_recipients']:
            value = getattr(item, list_dict_field)
            if value:
                raw_dict[list_dict_field] = map(lambda x: parse_object_as_dict(x), value)

        if item.folder:
            raw_dict['folder'] = parse_folder_as_json(item.folder)

        if compact_fields:
            new_dict = {}
            for field in ['datetime_created', 'datetime_received', 'datetime_sent',
                          'has_attachments', 'importance', 'item_id', 'last_modified_time',
                          'size', 'subject', 'text_body', 'headers']:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field)
            for field in ['received_by', 'author', 'sender']:
                new_dict[field] = raw_dict.get(field, {}).get('email_address')
            for field in ['to_recipients']:
                if field in raw_dict:
                    new_dict[field] = map(lambda x: x.get('email_address'), raw_dict[field])
            raw_dict = new_dict

        if camel_case:
            raw_dict = keys_to_camel_case(raw_dict)

        return raw_dict


    def parse_item_as_json(item):
        return json.dumps(parse_item_as_dict(item), ensure_ascii=False)


    def parse_incident_from_item(item):
        incident = {}
        labels = []

        incident['details'] = item.text_body
        incident['name'] = item.subject
        labels.append({'type': 'Email/subject', 'value': item.subject})
        incident['occurred'] = item.datetime_created.ewsformat()

        # handle recipients
        if item.to_recipients:
            for recipient in item.to_recipients:
                labels.append({'type': 'Email', 'value': recipient.email_address})

        # handle cc
        if item.cc_recipients:
            for recipient in item.cc_recipients:
                labels.append({'type': 'Email/cc', 'value': recipient.email_address})

        # handle email from
        if item.sender:
            labels.append({'type': 'Email/from', 'value': item.sender.email_address})

        # email format
        email_format = ''
        if item.text_body:
            labels.append({'type': 'Email/text', 'value': item.text_body})
            email_format = 'text'
        if item.body:
            labels.append({'type': 'Email/html', 'value': item.body})
            email_format = 'HTML'
        labels.append({'type': 'Email/format', 'value': email_format})

        # hadnle attachments
        if item.attachments:
            for attachment in item.attachments:
                if isinstance(attachment, FileAttachment):
                    # file attachment
                    label_attachment_type = 'attachments'
                    label_attachment_id_type = 'attachmentId'
                else:
                    # other item attachment
                    label_attachment_type = 'attachmentItems'
                    label_attachment_id_type = 'attachmentItemsId'
                labels.append({'type': label_attachment_type, 'value': attachment.name})
                labels.append({'type': label_attachment_id_type, 'value': attachment.attachment_id.id})

        # handle headers
        if item.headers:
            for header in item.headers:
                labels.append({'type': 'Email/Header/' + header.name, 'value': header.value})

        # handle item id
        if item.message_id:
            labels.append({'type': 'Email/ID', 'value': item.item_id})
            labels.append({'type': 'Email/MessageID', 'value': item.message_id})

        incident['labels'] = labels
        incident['rawJSON'] = parse_item_as_json(item)

        return incident


    def fetch_emails_as_incidents(account, folder_name):
        start_time = EWSDateTime.now(tz=EWSTimeZone.timezone('UTC'))
        last_run = get_last_run()
        last_emails = fetch_last_emails(account, folder_name, last_run.get('lastRunTime'), last_run.get('ids'))

        ids = []
        incidents = []
        for item in last_emails:
            ids.append(item.message_id)
            incident = parse_incident_from_item(item)
            incidents.append(incident)

        new_last_run = {
            'lastRunTime': start_time.ewsformat(),
            'folderName': folder_name,
            'ids': ids
        }

        demisto.setLastRun(new_last_run)
        return incidents


    def get_entry_for_file_attachment(attachment):
        entry = fileResult(attachment.name, attachment.content)
        ec = {
            'EWS.FileAttachments(val.attachmentID == obj.attachmentID)': parse_attachment_as_dict(attachment)
        }
        entry['EntryContext'] = ec
        return entry


    def parse_attachment_as_dict(attachment):
        return {
            'attachmentId': attachment.attachment_id.id,
            'attachmentName': attachment.name,
            'attachmentContentType': attachment.content_type,
            'attachmentContentId': attachment.content_id,
            'attachmentContentLocation': attachment.content_location,
            'attachmentSize': attachment.size,
            'attachmentLastModifiedTime': attachment.last_modified_time.ewsformat(),
            'attachmentIsInline': attachment.is_inline
        }


    def get_entry_for_item_attachment(attachment, target_email):
        item = attachment.item
        dict_result = parse_attachment_as_dict(attachment)
        dict_result.update(parse_item_as_dict(item, camel_case=True, compact_fields=True))
        dict_result['targetMailbox'] = target_email
        title = 'EWS get attachment got item for "%s", "%s"' % (target_email, attachment.name)

        return get_entry_for_object(title, 'EWS.Items(val.attachmentID == obj.attachmentID)', dict_result)


    def get_attachments_for_item(item_id, account, attachment_ids=None):
        item = get_item_from_mailbox(account, item_id)
        attachments_found = False
        attachments = []
        if attachment_ids and not isinstance(attachment_ids, list):
            attachment_ids = attachment_ids.split(",")
        if item:
            if item.attachments:
                for attachment in item.attachments:
                    attachments_found = True
                    if attachment_ids and attachment.attachment_id.id not in attachment_ids:
                        continue
                    attachments.append(attachment)

        else:
            raise Exception('Message item not found: ' + item_id)

        if attachments_found and len(attachments) == 0 and attachment_ids:
            raise Exception('Attachment id did not found for message:' + attachment_ids)

        return attachments


    def delete_attachments_for_message(item_id, target_mailbox=None, attachment_ids=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        attachments = get_attachments_for_item(item_id, account, attachment_ids)
        attachment_ids = []
        for attachment in attachments:
            attachment_ids.append(attachment.attachment_id.id)
            attachment.detach()

        delete_attachments_result = {
            'ids': attachment_ids
        }

        return get_entry_for_object('Deleted attachments',
                                    'EWS.DeletedAttachments',
                                    delete_attachments_result)


    def fetch_attachments_for_message(item_id, target_mailbox=None, attachment_ids=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        attachments = get_attachments_for_item(item_id, account, attachment_ids)
        entries = []
        for attachment in attachments:
            if isinstance(attachment, FileAttachment):
                entries.append(get_entry_for_file_attachment(attachment))
            else:
                entries.append(get_entry_for_item_attachment(attachment, account.primary_smtp_address))

        return entries


    def test_module():
        try:
            account = get_account(ACCOUNT_EMAIL)
            get_folder_by_path(account.root, FOLDER_NAME)
            demisto.results('ok')
        except Exception:
            demisto.results('failed')


    def move_item(item_id, target_folder_path, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        target_folder = get_folder_by_path(account.root, target_folder_path)
        item = get_item_from_mailbox(account, item_id)
        item.move(target_folder)
        move_result = {
            'newItemID': item.item_id,
            'itemId': item_id,
            'messageID': item.message_id
        }

        return get_entry_for_object('Moved items', 'EWS.MovedItems', move_result)


    def delete_items(item_ids, delete_type, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        message_ids = []
        item_ids = item_ids.split(",")
        items = get_items_from_mailbox(account, item_ids)
        delete_type = delete_type.lower()
        for item in items:
            if delete_type == 'trash':
                item.move_to_trash()
            elif delete_type == 'soft':
                item.soft_delete()
            elif delete_type == 'hard':
                item.delete()
            else:
                raise Exception('invalid delete type: %s. please use "trash" \\ "soft" \\ "hard"' % delete_type)
            message_ids.append(item.message_id)

        delete_result = {
            'messageIds': message_ids
        }
        return get_entry_for_object('Deleted items (%s delete type)' % delete_type,
                                    'EWS.DeletedItems',
                                    delete_result)


    def prepare_args(d):
        return dict((k.replace("-", "_"), v) for k, v in d.items())


    def search_items_in_mailbox(query, folder_path, target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        folder = get_folder_by_path(account.root, folder_path) if folder_path else Folder(account=account)
        items = folder.filter(query)
        searched_items_result = map(lambda item: parse_item_as_dict(item, camel_case=True, compact_fields=True), items)
        hm_headers = ['sender', 'subject', 'hasAttachments', 'datetimeReceived',
                      'receivedBy', 'author', 'toRecipients', ]
        return get_entry_for_object('Searched items',
                                    'EWS.SearchItems',
                                    searched_items_result,
                                    headers=hm_headers)


    def get_out_of_office_state(target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        oof = account.oof_settings
        oof_dict = {
            'state': oof.state,
            'externalAudience': getattr(oof, 'external_audience', None),
            'start': oof.start.ewsformat() if oof.start else None,
            'end': oof.end.ewsformat() if oof.end else None,
            'internalReply': getattr(oof, 'internal_replay', None),
            'externalReply': getattr(oof, 'external_replay', None),
            'account': account.primary_smtp_address
        }
        return get_entry_for_object("Out of office state for %s" % account.primary_smtp_address,
                                    "EWS.OutOfOffice",
                                    oof_dict)


    def recover_soft_delete_item(message_ids, target_folder_path="Inbox", target_mailbox=None):
        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        target_folder = get_folder_by_path(account.root, target_folder_path)
        recovered_message_ids = []
        for item in account.recoverable_items_deletions.filter(message_id__in=message_ids.split(",")).all():
            item.move(target_folder)
            recovered_message_ids.append(item.message_id)
        return get_entry_for_object("Recovered messages", "EWS.RecoveredMessages", {'messageIds': recovered_message_ids})


    def get_contacts(target_mailbox=None):
        def parse_physical_address(address):
            result = {}
            for attr in ['city', 'country', 'label', 'state', 'street', 'zipcode']:
                result[attr] = getattr(address, attr)
            return result

        def parse_phone_number(phone_number):
            result = {}
            for attr in ['label', 'phone_number']:
                result[attr] = getattr(phone_number, attr)
            return result

        def parse_contact(contact):
            contact_dict = dict((k, v if not isinstance(v, EWSDateTime) else v.ewsformat())
                                for k, v in contact.__dict__.items()
                                if isinstance(v, basestring) or isinstance(v, EWSDateTime))
            if contact.physical_addresses:
                contact_dict['physical_addresses'] = map(parse_physical_address, contact.physical_addresses)
            if contact.phone_numbers:
                contact_dict['phone_numbers'] = map(parse_phone_number, contact.phone_numbers)
            if contact.email_addresses and len(contact.email_addresses) > 0:
                contact_dict['emailAddresses'] = map(lambda x: x.email, contact.email_addresses)
            contact_dict = keys_to_camel_case(contact_dict)
            contact_dict = dict((k, v) for k, v in contact_dict.items() if v)
            del contact_dict['mimeContent']
            return contact_dict

        account = get_account(target_mailbox or ACCOUNT_EMAIL)
        contacts = map(parse_contact, account.contacts.all())
        return get_entry_for_object('Email contacts for %s' % target_mailbox,
                                    'EWS.Contacts',
                                    contacts)


    config = prepare()
    args = prepare_args(demisto.args())

    if demisto.command() == 'test-module':
        test_module()
    elif demisto.command() == 'fetch-incidents':
        incidents = fetch_emails_as_incidents(get_account(ACCOUNT_EMAIL), FOLDER_NAME)
        demisto.incidents(incidents)
    elif demisto.command() == 'py-ews-get-attachment':
        demisto.results(fetch_attachments_for_message(**args))
    elif demisto.command() == 'py-ews-delete-attachment':
        demisto.results(delete_attachments_for_message(**args))
    elif demisto.command() == 'py-ews-get-searchable-mailboxes':
        demisto.results(get_searchable_mailboxes(config.protocol))
    elif demisto.command() == 'py-ews-search-mailboxes':
        demisto.results(search_mailboxes(config.protocol, **args))
    elif demisto.command() == 'py-ews-move-item':
        demisto.results(move_item(**args))
    elif demisto.command() == 'py-ews-delete-items':
        demisto.results(delete_items(**args))
    elif demisto.command() == 'py-ews-search-mailbox':
        demisto.results(search_items_in_mailbox(**args))
    elif demisto.command() == 'py-ews-get-contacts':
        demisto.results(get_contacts())
    elif demisto.command() == 'py-ews-get-out-of-office':
        demisto.results(get_out_of_office_state(**args))
    elif demisto.command() == 'py-ews-recover-messages':
        demisto.results(recover_soft_delete_item(**args))
  type: python
  commands:
  - name: py-ews-get-attachment
    arguments:
    - name: item-id
      required: true
      description: The ID of the email message to get the attachments.
    - name: target-mailbox
      description: The mailbox where this attachment was found. Use the default mailbox
        if empty, otherwise user has to be with impersonation rights to this mailbox.
    - name: attachment-ids
      description: The attachments ids to get. If none - all attachments will be retrieve
        from the message. Support multiple attachments with comma-separated value
        or array.
      isArray: true
    outputs:
    - contextPath: EWS.FileAttachments.attachmentId
      description: The attachment ID. Used for file attachments only.
    - contextPath: EWS.FileAttachments.attachmentName
      description: The attachment name. Used for file attachments only.
    - contextPath: EWS.FileAttachments.attachmentLastModifiedTime
      description: The attachment last modified time. Used for file attachments only.
    - contextPath: EWS.Items.datetimeCreated
      description: The attached email created time.
    - contextPath: EWS.Items.datetimeReceived
      description: The attached email received time.
    - contextPath: EWS.Items.datetimeSent
      description: The attached email sent time.
    - contextPath: EWS.Items.receivedBy
      description: The attached email received by address.
    - contextPath: EWS.Items.subject
      description: The attached email subject.
    - contextPath: EWS.Items.textBody
      description: The attached email text body.
    - contextPath: EWS.Items.headers
      description: The attached email headers.
    - contextPath: EWS.Items.hasAttachments
      description: Is attached email has attachments?
    - contextPath: EWS.Items.itemId
      description: The attached email item id.
    - contextPath: EWS.Items.toRecipients
      description: The attached email to recipients.
    description: Get actual attachment item from email
  - name: py-ews-delete-attachment
    arguments:
    - name: item-id
      required: true
      description: The ID of the email message to get the attachments.
    - name: target-mailbox
      description: The mailbox where this attachment was found. Use the default mailbox
        if empty, otherwise user has to be with impersonation rights to this mailbox.
    - name: attachment-ids
      description: The attachment id to delete. If none - all attachments will be
        delete from the message. Support multiple attachments with comma-separated
        value or array.
      isArray: true
    outputs:
    - contextPath: EWS.DeletedAttachments.ids
      description: The ids of the deleted attachments.
    description: Delete attachments for message.
  - name: py-ews-get-searchable-mailboxes
    arguments: []
    outputs:
    - contextPath: EWS.Mailboxes.mailbox
      description: Searchable mailboxes addresses.
    - contextPath: EWS.Mailboxes.mailboxId
      description: Searchable mailboxes ids.
    - contextPath: EWS.Mailboxes.displayName
      description: Searchable mailboxes - display name of the email.
    - contextPath: EWS.Mailboxes.isExternal
      description: Searchable mailboxes - is mailbox external?
    - contextPath: EWS.Mailboxes.externalEmailAddress
      description: Searchable mailboxes - external email address.
    description: 'Get searchable mailboxes. '
  - name: py-ews-search-mailboxes
    arguments:
    - name: filter
      required: true
      description: The filter query to search.
    - name: mailbox-search-scope
      required: true
      description: The mailboxes ids to search for. Usually use py-ews-search-mailboxes
        command output -EWS.Mailboxes.mailboxId.
      isArray: true
    outputs:
    - contextPath: EWS.Searches.Search.Filter
      description: The search filter
      type: string
    - contextPath: EWS.Searches.Search.Results.messageId
      description: The message id
      type: string
    - contextPath: EWS.Searches.Search.Results.mailbox
      description: The mailbox address where the item has been found
      type: string
    - contextPath: EWS.Searches.Search.Results.subject
      description: Email subject
      type: string
    - contextPath: EWS.Searches.Search.Results.toRecipients
      description: Email to recipients
    - contextPath: EWS.Searches.Search.Results.sender
      description: Sender email address
      type: string
    - contextPath: EWS.Searches.Search.hasAttachment
      description: Does email has attachments?
      type: boolean
    - contextPath: EWS.Searches.Search.sentTime
      description: Email sent time
      type: date
    - contextPath: EWS.Searches.Search.receivedTime
      description: Email receive time
      type: date
  - name: py-ews-move-item
    arguments:
    - name: item-id
      required: true
      description: The item id to move.
    - name: target-folder-path
      required: true
      description: The target folder to move the item to. Complex path can be used,
        e.g. Inbox\Phishing.
    - name: target-mailbox
      description: 'The mailbox where the item is. Use the default mailbox if empty,
        otherwise user has to be with impersonation rights to this mailbox. '
    outputs:
    - contextPath: EWS.MovedItems.newItemID
      description: The new item id after move.
    - contextPath: EWS.MovedItems.messageID
      description: The item message id.
    - contextPath: EWS.MovedItems.itemId
      description: The original item id.
    description: Move item to another folder in the mailbox.
  - name: py-ews-delete-items
    arguments:
    - name: item-ids
      required: true
      description: The item ids to delete.
    - name: delete-type
      required: true
      description: 'Deletion type, choose one of: trash, soft, hard.'
      defaultValue: soft
    - name: target-mailbox
      description: The mailbox where the items in. Use the default mailbox if empty,
        otherwise user has to be with impersonation rights to this mailbox.
    outputs:
    - contextPath: EWS.DeletedItems.messageIds
      description: The deleted items message ids.
    description: Delete items from mailbox.
  - name: py-ews-search-mailbox
    arguments:
    - name: query
      required: true
      description: 'The search query string. Syntax here: https://msdn.microsoft.com/en-us/library/ee693615.aspx'
    - name: folder-path
      required: true
      description: The folder path to search in.
      defaultValue: Inbox
    - name: target-mailbox
      description: The target mailbox to search in. Use the default mailbox if empty,
        otherwise user has to be with impersonation rights to this mailbox.
    description: Search in specific mailbox. Notice that impersonation needed for
      this operation to search in another target mailbox than the default.
  - name: py-ews-get-contacts
    arguments:
    - name: target-mailbox
      description: The mailbox to get the contacts from. Use the default mailbox if
        empty, otherwise user has to be with impersonation rights to this mailbox.
    outputs:
    - contextPath: EWS.Contacts.displayName
      description: The contact name.
    - contextPath: EWS.Contacts.lastModifiedTime
      description: The contact last modified time.
    - contextPath: EWS.Contacts.emailAddresses
      description: The contact phone numbers.
    - contextPath: EWS.Contacts.physicalAddresses
      description: The contact physical addresses.
    - contextPath: EWS.Contacts.phoneNumbers.phoneNumber
      description: The contact email addresses.
    description: Get contacts for mailbox.
  - name: py-ews-get-out-of-office
    arguments:
    - name: target-mailbox
      required: true
      description: The mailbox to get out-of-office status. User has to be with impersonation
        rights to this mailbox.
    outputs:
    - contextPath: EWS.OutOfOffice.state
      description: 'Out-of-office state. Result can be: Enabled, Scheduled, Disabled.'
    - contextPath: EWS.OutOfOffice.externalAudience
      description: 'Out-of-office external audience. Result can be: None, Known, All.'
    - contextPath: EWS.OutOfOffice.start
      description: Out-of-office start date.
    - contextPath: EWS.OutOfOffice.end
      description: Out-of-office end date.
    - contextPath: EWS.OutOfOffice.internalReply
      description: Out-of-office internal replay.
    - contextPath: EWS.OutOfOffice.externalReply
      description: Out-of-office external replay.
    - contextPath: EWS.OutOfOffice.account
      description: Out-of-office mailbox.
    description: Get out-of-office status for mailbox.
  - name: py-ews-recover-messages
    arguments:
    - name: message-ids
      required: true
      description: The messages ids. Comma-separate value. Usually use the output
        of py-ews-delete-items.
    - name: target-folder-path
      required: true
      description: The folder path to recover the messages to.
      defaultValue: Inbox
    - name: target-mailbox
      description: The mailbox where the messages found. Use the default mailbox if
        empty, otherwise user has to be with impersonation rights to this mailbox.
    outputs:
    - contextPath: EWS.RecoveredMessages.messageIds
      description: The recovered message ids.
    description: Recover messages that has beed deleted (soft-delete).
  dockerimage: demisto/py-ews:latest
  isfetch: true
  runonce: false
releaseNotes: EWS (Exchange Web Services) integration