// Default timeout and interval parameters for polling the response
CLIENT_COMMAND_PARAMETERS = {
    'sep-update-content'    : {'timeout': 120, 'interval': 10},
    'sep-scan'              : {'timeout': 300, 'interval': 30},
    'sep-quarantine'    : {'timeout': 120, 'interval': 10}
}

var fixUrl = function(base) {
  res = base;
  if (base && base[base.length - 1] != '/') {
      res = res + '/';
  }
  return res;
}

var buildArgs = function(args) {
    sArgs = Object.keys(args).map(function(key) {
        return [key, args[key]].map(encodeURIComponent).join("=");
    }).join("&");
    if (sArgs) {
        return '?' + sArgs;
    } else {
        return '';
    }
}

String.prototype.format = function() {
   var content = this;
   for (var i=0; i < arguments.length; i++)
   {
        var replacement = '{' + i + '}';
        content = content.replace(replacement, arguments[i]);
   }
   return content;
}

function objToStr(o) {
    if (Array.isArray(o)) {
        return o.map(function(v) {
            return objToStr(v);
        }).join(',');
    } else if (typeof(o) === 'string') {
        return o;
    } else {
        return JSON.stringify(o);
    }
}

function objToMd(o) {
    var keys = Object.keys(o);
    keys.sort();
    var md = 'Key | Value\n- | -\n';
    for (var i in keys) {
        md += keys[i] + ' | ' + objToStr(o[keys[i]]) + '\n';
    }
    return md;
}

function argToList(arg){
    if (!arg){
        return [];
    } else if (arg instanceof Array) {
        return arg;
    } else if (typeof arg === "string") {
        if (arg[0] === '[' && arg[-1] === ']'){
            return JSON.parse(arg);
        } else {
            return arg.split(',');
        }
    }
}

function tblToMd(name, t, headers) {
    if (!(t instanceof Array)){
        t = [t];
    }
    if (!(headers instanceof Array && headers.length > 0) || !headers){
        headers = Object.keys(t[0]);
        headers.sort();
    }

    var mdResults = '';
    if (name) {
        mdResults = '### ' + name + '\n';
    }
    if (t) {
        mdResults += headers.join('|') + '\n';
        var sep = [];
        headers.forEach(function(h) {
            sep.push('-');
        });
        mdResults += sep.join('|') + '\n';
        t.forEach(function(entry) {
            var vals = [];
            headers.forEach(function(h) {
                // add escape to the output of formatCell
                vals.push(!!entry[h] ? formatCell(entry[h]) : ' ');
            });
            mdResults += vals.join('|') + '\n';
        });
    } else {
        mdResults += '**No entries.**\n';
    }

    return mdResults;
}

var buildClientXml = function(data) {
    return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:cli="http://client.webservice.sepm.symantec.com/"> \
            <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data);
}

var buildCommandXml = function(data) {
    return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:com="http://command.client.webservice.sepm.symantec.com/"> \
            <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data);
}

var parseResponse = function(resp) {
  if (resp.StatusCode === 200) {
      try {
          return JSON.parse(resp.Body);
      } catch (e) {
          return resp.Body;
      }
  } else {
    err = resp.Status;
    if (resp.Body) {
        err += '\n' + resp.Body;
    }
    throw err;
  }
}

var doAuth = function(qParams) {
  url = fixUrl(qParams.server) + 'sepm/api/v1/identity/authenticate';
  u = qParams.authentication ? qParams.authentication.identifier : '';
  p = qParams.authentication ? qParams.authentication.password : '';
  d = qParams.domain ? qParams.domain : '';
  body = {
          username: u,
          password: p,
          domain: d
      };
  res = http(
      url, // URL
      {
          Method: 'POST',
          Headers: {"Content-Type": ["application/json"]},
          Body: JSON.stringify(body)
      },
      qParams['insecure']
  );
  return res;
};

var doGet = function(qArgs, qParams, token, raw, suffix) {
  url = fixUrl(qParams.server) + suffix + buildArgs(qArgs);
    res = http(
        url,
        {
            Method: 'GET',
            Headers: {'Authorization': ['Bearer ' + token]}
        },
        qParams.insecure
    );

  if (raw) {
      return res;
  } else {
      return parseResponse(res);
  }
}

var doPost = function(qArgs, qParams, token, is_xml, suffix, body) {
  url = fixUrl(qParams.server) + suffix;
  res = http(
      url, // URL
      { // HTTP Request Headers
          Method: 'POST',
          Headers: {'Authorization': ['Bearer ' + token]},
          //Body: JSON.stringify(body)
          Body: body

      },
      qParams.insecure
  );

  res = parseResponse(res);
  if (is_xml) {
    res = JSON.parse(x2j(res));
  }

  return res;
}

var systemInfo = function(qArgs, qParams, token) {
    versionJson = doGet(args, params, token, false, 'sepm/api/v1/version');
    avdefJson = doGet(args, params, token, false, 'sepm/api/v1/content/avdef/latest');

    var systemInfoJson = {
        'version': versionJson,
        'avdef': avdefJson
    };

    var md = '## System Information\n';
    md += '### Version\n';
    md += objToMd(versionJson);
    md += '### AV Definitions\n';
    md += objToMd(avdefJson);

    return {
        Type: entryTypes.note, Contents: systemInfoJson, ContentsFormat: formats.json, HumanReadable: md,
        EntryContext: {'sepm.ServerAVDefPublishDate': systemInfoJson.avdef.publishedBySymantec}
    };
}

var clientContent = function(qArgs, qParams, token) {
    clientContentJson = doGet(args, params, token, false, 'sepm/api/v1/stats/client/content');

    var md = '## Client Content, last updated on {0}\n'.format(clientContentJson.lastUpdated);
    md += tblToMd(clientContentJson.clientDefStatusList);

    return {
        Type: entryTypes.note, Contents: clientContentJson.clientDefStatusList, ContentsFormat: formats.json, HumanReadable: md,
        EntryContext: {'sepm.clientContent': clientContentJson.clientDefStatusList}
    };
}

var endpointsInfo = function(qArgs, qParams, token) {
    jsonRes = doGet(args, params, token, false, 'sepm/api/v1/computers');

    // var md = '## Endpoints\n';
    // for (var i = 0; i < jsonRes.content.length; i++) {
    //     md += tblToMd('Endpoint ' + (i + 1), jsonRes.content[i], argToList(qArgs.keys));
    // }
    md = tblToMd('Endpoints', jsonRes.content, argToList(qArgs.keys));

    return {Type: entryTypes.note, Contents: jsonRes, ContentsFormat: formats.json, HumanReadable: md, EntryContext: {'sepm.endpoints': jsonRes}};
}

var groupsInfo = function(qArgs, qParams, token) {
    jsonRes = doGet(args, params, token, false, 'sepm/api/v1/groups');
    md = tblToMd('Groups', jsonRes.content, argToList(qArgs.keys));

    return {Type: entryTypes.note, Contents: jsonRes, ContentsFormat: formats.json, HumanReadable: md, EntryContext: {'sepm.groups': jsonRes}};
}

var getComputerIdByIp = function(qParams, token, ip) {
    xml = buildClientXml('<cli:getComputersByIP><ipAddresses>{0}</ipAddresses></cli:getComputersByIP>'.format(ip));
    resJson = doPost(null, qParams, token, true, 'sepm/ws/v1/ClientService', xml);

    return resJson.Envelope.Body.getComputersByIPResponse.ComputerResult.computers.computerId;
}

var getComputerIdByHostname = function(qParams, token, hostname) {
    xml = buildClientXml('<cli:getComputersByHostName><computerHostNames>{0}</computerHostNames></cli:getComputersByHostName>'.format(hostname));
    resJson = doPost(null, qParams, token, true, 'sepm/ws/v1/ClientService', xml);

    return resJson.Envelope.Body.getComputersByHostNameResponse.ComputerResult.computers.computerId;
}

var getComputerId = function(qParams, qArgs, token) {
    if (qArgs.ip) {
        try {
            computerId = getComputerIdByIp(qParams, token, qArgs.ip);
        } catch (err) {
            throw 'Failed to locate the endpoint by its IP address.';
        }
    } else if (qArgs.hostname) {
        try {
            computerId = getComputerIdByHostname(qParams, token, qArgs.hostname);
        } catch (err) {
            throw 'Failed to locat the endpoint by its hostname.';
        }
    } else {
        throw 'Please provide the IP address or the hostname of endpoint.';
    }

    return computerId;
}

var getCommandStatusDetails = function(qParams, token, commandId) {
    xml = buildCommandXml('<com:getCommandStatusDetails><commandID>{0}</commandID></com:getCommandStatusDetails>'.format(commandId));
    resJson = doPost(null, qParams, token, true, 'sepm/ws/v1/CommandService', xml);

    return resJson;
}

var pollResponse = function(qParams, qArgs, token, commandId, timeout, interval) {
    retries = timeout / interval;
    isDone = false;
    for (var i = 0; i < retries; i++) {
        commandStatusJson = getCommandStatusDetails(qParams, token, commandId);
        cmdStatusDetail = commandStatusJson.Envelope.Body.getCommandStatusDetailsResponse.CommandStatusDetailResult.cmdStatusDetail;
        stateId = cmdStatusDetail.stateId;
        if (stateId == '3') {
            isDone = true;
            break;
        }

        wait(interval);
    }

    message = isDone ? 'Command finished.' : 'Command is not done.\nIn order to fetch the state of the command, run "!sep-command-status" with the commandId.'

    return {
        'cmdStatusDetail': cmdStatusDetail,
        'message': message
    }
}

var buildCommandResponseOutput = function(commandId, response) {
    md = objToMd(response['cmdStatusDetail']) + '\n';
    md += '### commandId = ' + commandId + '\n';
    md += '### ' + message;

    return {Type: entryTypes.note, Contents: response['cmdStatusDetail'], ContentsFormat: formats.json, HumanReadable: md, EntryContext: {'sepm.lastCommandId': commandId}};
}

var runClientCommand = function(qArgs, qParams, token, command) {
    try {
        computerId = getComputerId(qParams, qArgs, token);
    }
    catch (err) {
        return {Type: entryTypes.error, Contents: err, ContentsFormat: formats.json, HumanReadable: err, EntryContext: {}};
    }

    timeout = qArgs.timeout ? parseInt(qArgs.timeout) : CLIENT_COMMAND_PARAMETERS[command]['timeout'];
    interval = qArgs.interval ? parseInt(qArgs.interval) : CLIENT_COMMAND_PARAMETERS[command]['interval'];

    switch (command) {
        case 'sep-update-content':
            commandId = updateContent(qArgs, qParams, token, computerId);
            break;
        case 'sep-scan':
            commandId = scan(qArgs, qParams, token, computerId);
            break;
        case 'sep-quarantine':
            commandId = quarantine(qArgs, qParams, token, computerId);
            break;
        default:
            throw 'Invalid command.';
    }

    response = pollResponse(qParams, qArgs, token, commandId, timeout, interval);

    return buildCommandResponseOutput(commandId, response);
}

var commandStatus = function(qArgs, qParams, token) {
    response = pollResponse(qParams, qArgs, token, qArgs.commandId, 1, 1);

    md = objToMd(response['cmdStatusDetail']) + '\n';
    md += '### ' + message;

    return {Type: entryTypes.note, Contents: response['cmdStatusDetail'], ContentsFormat: formats.json, HumanReadable: md, EntryContext: {}};
}

var updateContent = function(qArgs, qParams, token, computerId) {
    xml = buildCommandXml('<com:runClientCommandUpdateContent><computerGUIDList>{0}</computerGUIDList></com:runClientCommandUpdateContent>'.format(computerId));
    resJson = doPost(qArgs, qParams, token, true, 'sepm/ws/v1/CommandService', xml);
    commandId = resJson.Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.commandId;

    return commandId;
}

var scan = function(qArgs, qParams, token, computerId) {
    xml = buildCommandXml('<com:runClientCommandScan><computerGUIDList>{0}</computerGUIDList><scanType>{1}</scanType></com:runClientCommandScan>'.format(computerId, qArgs.scanType));
    resJson = doPost(qArgs, qParams, token, true, 'sepm/ws/v1/CommandService', xml);
    commandId = resJson.Envelope.Body.runClientCommandScanResponse.CommandClientResult.commandId;

    return commandId;
}

var quarantine = function(qArgs, qParams, token, computerId) {
    xml = buildCommandXml('<com:runClientCommandQuarantine><command><commandType>{0}</commandType><targetObjectIds>{1}</targetObjectIds><targetObjectType>COMPUTER</targetObjectType></command></com:runClientCommandQuarantine>'.format(qArgs.actionType, computerId));
    resJson = doPost(qArgs, qParams, token, true, 'sepm/ws/v1/CommandService', xml);
    commandId = resJson.Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.commandId;

    return commandId;
}

// First authenticate and get a token
var resp = doAuth(params);
var token;
if (resp.StatusCode === 200) {
    token = JSON.parse(resp.Body).token;
} else {
    return resp;
}

// The command input arg holds the command sent from the user.
switch (command) {
    // This is the call made when pressing the integration test button.
    case 'test-module':
        if (resp.StatusCode === 200) {
            return 'ok';
        } else if (resp.Status) {
            return resp.Status;
        } else {
            return resp;
        }
        break;
    case 'sep-system-info':
        return systemInfo(args, params, token);
    case 'sep-client-content':
        return clientContent(args, params, token);
    case 'sep-endpoints-info':
        return endpointsInfo(args, params, token);
    case 'sep-groups-info':
        return groupsInfo(args, params, token);
    case 'sep-command-status':
        return commandStatus(args, params, token);
    case 'sep-update-content':
    case 'sep-scan':
    case 'sep-quarantine':
        return runClientCommand(args, params, token, command);
    default:
}
